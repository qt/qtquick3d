// Copyright (C) 2014 NVIDIA Corporation.
// Copyright (C) 2023 The Qt Company Ltd.
// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR GPL-3.0-only

#ifndef SHADOW_MAPPING_GLSLLIB
#define SHADOW_MAPPING_GLSLLIB

#include "depthpass.glsllib"


float qt_sampleCubemap( in samplerCube shadowCube, in ShadowData shadowData, in vec3 lightPos, in vec3 worldPos )
{
    float dist = length(worldPos - lightPos);
    float currentDepth = clamp((dist - shadowData.clipNear) / (shadowData.shadowMapFar - shadowData.clipNear), 0.0, 1.0);
    vec3 smpCoord = worldPos - lightPos;

    // reverse Y if shadowData.isYUp == 1 (not enough on its own, also expects +Y and -Y swapped in shadowCube)
    smpCoord.y = mix(smpCoord.y, -smpCoord.y, shadowData.isYUp);

    float sampleDepth = texture( shadowCube, smpCoord ).x + shadowData.bias;
    return min(1.0, exp(shadowData.factor * sampleDepth) / exp(shadowData.factor * currentDepth));
}

int findSplitIndex(in float depth, in vec4 splits, in vec4 splitActive, in int numSplits) {
    for (int i = 0; i < min(numSplits + 1, 4); i++) {
        if (depth < splits[i]) {
            return splitActive[i] > 0.f ? i : -1;
        }
    }

    return -1;
}

float qt_sampleOrthographic_splitIndex(in sampler2DArray shadowMap,
                                               in float shadowBias,
                                               in float shadowFactor,
                                               in float flipY,
                                               in vec4 projCoord,
                                               in float layerIndex)
{
    vec3 smpCoord = projCoord.xyz / projCoord.w;
    smpCoord.y = mix(smpCoord.y, 1.0 - smpCoord.y, flipY);
    float sampleDepth = texture(shadowMap, vec3(smpCoord.xy, layerIndex)).r + shadowBias;
    return min(1.0, exp(shadowFactor * sampleDepth) / exp(shadowFactor * smpCoord.z));

}

float qt_sampleOrthographic( in sampler2DArray shadowMap, in ShadowData shadowData, in float zDepthViewSpace, in vec3 worldPos )
{
    int splitIndex = findSplitIndex(zDepthViewSpace, shadowData.csmSplits, shadowData.csmActive, shadowData.csmNumSplits);

    if (splitIndex == -1)
        return 1.0f;

    vec4 projCoord = shadowData.matrices[splitIndex] * vec4( worldPos, 1.0 );
    float shadow = qt_sampleOrthographic_splitIndex(shadowMap, shadowData.bias, shadowData.factor, float(shadowData.isYUp), projCoord, float(shadowData.layerIndex + splitIndex));

    if (splitIndex == 0) {
        return shadow;
    }

    float splitPrev = shadowData.csmSplits[splitIndex - 1];
    float split = shadowData.csmSplits[splitIndex];

    float bandLength = shadowData.clipFar * shadowData.csmBlendRatio;
    if (zDepthViewSpace < splitPrev + bandLength && shadowData.csmActive[splitIndex - 1] > 0.0) {
        vec4 projCoordPrev = shadowData.matrices[splitIndex - 1] * vec4(worldPos, 1.0 );
        float shadowPrev = qt_sampleOrthographic_splitIndex(shadowMap, shadowData.bias, shadowData.factor, float(shadowData.isYUp), projCoordPrev, float(shadowData.layerIndex + splitIndex - 1));
        float t = (splitPrev + bandLength - zDepthViewSpace) / bandLength;
        shadow = mix(shadow, shadowPrev, t);
    }

    return shadow;
}

#endif
